from tornado_py3 import httputil as httputil
from tornado_py3.escape import url_escape as url_escape, url_unescape as url_unescape, utf8 as utf8
from tornado_py3.log import app_log as app_log
from tornado_py3.util import basestring_type as basestring_type, import_object as import_object, re_unescape as re_unescape, unicode_type as unicode_type
from typing import Any, Awaitable, Dict, Optional, Pattern, Union

class Router(httputil.HTTPServerConnectionDelegate):
    def find_handler(self, request: httputil.HTTPServerRequest, **kwargs: Any) -> Optional[httputil.HTTPMessageDelegate]: ...
    def start_request(self, server_conn: object, request_conn: httputil.HTTPConnection) -> httputil.HTTPMessageDelegate: ...

class ReversibleRouter(Router):
    def reverse_url(self, name: str, *args: Any) -> Optional[str]: ...

class _RoutingDelegate(httputil.HTTPMessageDelegate):
    server_conn: Any = ...
    request_conn: Any = ...
    delegate: Any = ...
    router: Any = ...
    def __init__(self, router: Router, server_conn: object, request_conn: httputil.HTTPConnection) -> None: ...
    def headers_received(self, start_line: Union[httputil.RequestStartLine, httputil.ResponseStartLine], headers: httputil.HTTPHeaders) -> Optional[Awaitable[None]]: ...
    def data_received(self, chunk: bytes) -> Optional[Awaitable[None]]: ...
    def finish(self) -> None: ...
    def on_connection_close(self) -> None: ...

class _DefaultMessageDelegate(httputil.HTTPMessageDelegate):
    connection: Any = ...
    def __init__(self, connection: httputil.HTTPConnection) -> None: ...
    def finish(self) -> None: ...

class RuleRouter(Router):
    rules: Any = ...
    def __init__(self, rules: _RuleList=...) -> None: ...
    def add_rules(self, rules: _RuleList) -> None: ...
    def process_rule(self, rule: Rule) -> Rule: ...
    def find_handler(self, request: httputil.HTTPServerRequest, **kwargs: Any) -> Optional[httputil.HTTPMessageDelegate]: ...
    def get_target_delegate(self, target: Any, request: httputil.HTTPServerRequest, **target_params: Any) -> Optional[httputil.HTTPMessageDelegate]: ...

class ReversibleRuleRouter(ReversibleRouter, RuleRouter):
    named_rules: Any = ...
    def __init__(self, rules: _RuleList=...) -> None: ...
    def process_rule(self, rule: Rule) -> Rule: ...
    def reverse_url(self, name: str, *args: Any) -> Optional[str]: ...

class Rule:
    matcher: Any = ...
    target: Any = ...
    target_kwargs: Any = ...
    name: Any = ...
    def __init__(self, matcher: Matcher, target: Any, target_kwargs: Dict[str, Any]=..., name: str=...) -> None: ...
    def reverse(self, *args: Any) -> Optional[str]: ...

class Matcher:
    def match(self, request: httputil.HTTPServerRequest) -> Optional[Dict[str, Any]]: ...
    def reverse(self, *args: Any) -> Optional[str]: ...

class AnyMatches(Matcher):
    def match(self, request: httputil.HTTPServerRequest) -> Optional[Dict[str, Any]]: ...

class HostMatches(Matcher):
    host_pattern: Any = ...
    def __init__(self, host_pattern: Union[str, Pattern]) -> None: ...
    def match(self, request: httputil.HTTPServerRequest) -> Optional[Dict[str, Any]]: ...

class DefaultHostMatches(Matcher):
    application: Any = ...
    host_pattern: Any = ...
    def __init__(self, application: Any, host_pattern: Pattern) -> None: ...
    def match(self, request: httputil.HTTPServerRequest) -> Optional[Dict[str, Any]]: ...

class PathMatches(Matcher):
    regex: Any = ...
    def __init__(self, path_pattern: Union[str, Pattern]) -> None: ...
    def match(self, request: httputil.HTTPServerRequest) -> Optional[Dict[str, Any]]: ...
    def reverse(self, *args: Any) -> Optional[str]: ...

class URLSpec(Rule):
    regex: Any = ...
    handler_class: Any = ...
    kwargs: Any = ...
    def __init__(self, pattern: Union[str, Pattern], handler: Any, kwargs: Dict[str, Any]=..., name: str=...) -> None: ...
