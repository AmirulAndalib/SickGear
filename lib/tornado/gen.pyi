import datetime
import types
import typing
from collections.abc import Generator
from tornado_py3.concurrent import Future as Future, chain_future as chain_future, future_add_done_callback as future_add_done_callback, future_set_exc_info as future_set_exc_info, future_set_result_unless_cancelled as future_set_result_unless_cancelled, is_future as is_future
from tornado_py3.ioloop import IOLoop as IOLoop
from tornado_py3.log import app_log as app_log
from tornado_py3.util import TimeoutError as TimeoutError
from typing import Any, Callable, Dict, List, Tuple, Type, Union

class KeyReuseError(Exception): ...
class UnknownKeyError(Exception): ...
class LeakedCallbackError(Exception): ...
class BadYieldError(Exception): ...
class ReturnValueIgnoredError(Exception): ...

def coroutine(func: Callable[..., Generator[Any, Any, _T]]) -> Callable[..., Future[_T]]: ...
def is_coroutine_function(func: Any) -> bool: ...

class Return(Exception):
    value: Any = ...
    args: Any = ...
    def __init__(self, value: Any=...) -> None: ...

class WaitIterator:
    current_index: Any = ...
    current_future: Any = ...
    def __init__(self, *args: Future, **kwargs: Future) -> None: ...
    def done(self) -> bool: ...
    def next(self) -> Future: ...
    def __aiter__(self) -> typing.AsyncIterator: ...
    def __anext__(self) -> Future: ...

def multi(children: Union[List[_Yieldable], Dict[Any, _Yieldable]], quiet_exceptions: Union[Type[Exception], Tuple[Type[Exception], ...]]=...) -> Union[Future[List], Future[Dict]]: ...
Multi = multi

def multi_future(children: Union[List[_Yieldable], Dict[Any, _Yieldable]], quiet_exceptions: Union[Type[Exception], Tuple[Type[Exception], ...]]=...) -> Union[Future[List], Future[Dict]]: ...
def maybe_future(x: Any) -> Future: ...
def with_timeout(timeout: Union[float, datetime.timedelta], future: _Yieldable, quiet_exceptions: Union[Type[Exception], Tuple[Type[Exception], ...]]=...) -> Future: ...
def sleep(duration: float) -> Future[None]: ...

class _NullFuture:
    def result(self) -> None: ...
    def done(self) -> bool: ...

moment: Any

class Runner:
    gen: Any = ...
    result_future: Any = ...
    future: Any = ...
    running: bool = ...
    finished: bool = ...
    io_loop: Any = ...
    def __init__(self, gen: Generator[_Yieldable, Any, _T], result_future: Future[_T], first_yielded: _Yieldable) -> None: ...
    def run(self) -> None: ...
    def handle_yield(self, yielded: _Yieldable) -> bool: ...
    def handle_exception(self, typ: Type[Exception], value: Exception, tb: types.TracebackType) -> bool: ...

def convert_yielded(yielded: _Yieldable) -> Future: ...

convert_yielded: Any
